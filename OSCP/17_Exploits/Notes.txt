Notes
Basic Buffer (stack) Overflow

In a stack based overflow we are try to exploit a poorly written application by inserting, into memory, too many characters for the stack to store. This will cause the instruction pointer (EIP) to be overwritten by the value of our input.

To find a vulnerable application you will need to try and crash it with whatever user input it accepts. You can print out a bunch of characters and copy/paste them in with  perl -e 'print "A" x 100000', or if it is a web app, you can use perl to pass command through a netcat session. perl -e 'print "A" x 100000' | netcat <IP> <port>

If we know the postion of the EIP/ESP within the stack we can craft an input that will overwrite that value with a pointer that we create. But how do we know how much memory space has been allocated for the initial input? Trial and error OR

Within metasploit-framework/tools we can use pattern-create.rb -l <length of desired bytes for input> to craft an input that can be used to determine the memory allocation space.

Example:
Step 1) For multithreaded applications you cannot just run gdb, you will need to capture the program as it crashes and offload the dump file, use ulimit -c unlimited. Then start the application, get the PID (ps -a <application>) and run gcore <PID> -o <outfile>. Or wait for the application to crash with your input and a core dump file should be created in the running directory of the app.

Step 2) Copy and paste the pattern created with pattern-create.rb into the input of the applicaiton (note: record the length of the pattern that you created). IF a web based applicaiton you can cat the input through a netcat session with cat <file> | nc <IP> <Port>

Step 3) gdp --core=<outfile>, now look at the character inserted at the EIP with "info reg". Now take that character and use the metasploit-framework/tool/pattern-offset.rb -q <character> -l <length of original pattern created>. The output will be the length of the buffer for that application! You should run/crash the application a few time and pay attention to the various pointers to determine if the stack pointers differ. This would be an indication that there is stack randomization protection in place or canaries :( At that point you may have to look for shared libraries that you could exploit. Record the ESP value for later!

Step 4) Now that you have your buffer size, time to find some shell code to input. https://www.exploit-db.com/shellcode/ is a good start to find prewritten code. There are also plenty examples in the metasploit framework (/usr/share/framework2/src/shellcode/). Run gcc -c <shellcode.c> to compile and get your <shellcode.o> .

Step 5) Once you have your <shellcode.o> you can run objdump -d <shellcode.o> to extract the binary strings that need to be passed to your application. Prefice all doubles with '\x' to identify them as hex. For example:

\x31\xc0\x31\xd2\xb0\x0b\x52\x66\x68\x2d\x63\x89\xe7\x52\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89
\xe3\x52\xeb\x06\x57\x53\x89\xe1\xcd\x80\xe8\xf5\xff\xff\xff\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64\x3b
\x65\x63\x68\x6f\x20\x64\x6f\x5f\x5f\x6e\x65

It's a good idea to pass this into a <shellcode.txt> file first. That way you can see the size (bytes) of the code and keep a copy.

NOTE: At this point we should know the size of the buffer in our vulnerable app and the size of our shell code. Now we need to take buffer - shellcode to get the amount of space we need to fill with NOPs (0x90). Because we don't know where the initital pointer for the process is pointing it is always benefical to use the smallest shell code being lead by the largest amount of NOPs. This is known as a NOP sled and will provide you with a large target area for the inital pointer and 'slide' you all the way to the start of the shell code.

Step 6) Time to craft the exploit, take the buffer you need to fill up with NOPs (ie buffer is 128 and shellcode is 28, you will need 100 NOPs) and create it with perl 'print "\x90" x 100' > nops. Take that ESP pointer and output it backwards (ie if the original value was 0xa1b2c310 you will need to use echo "\0x10\0xc3\0xb2\0xa1" > address. You should have 3 files now, <shellcode>/nops/address. Now you can cat (in order!) nops <shellcode> address into the netcat listener or enter it into the application.

Step 7) Most likely this will fail because what we are doing is corrupting memory and crashing a program, if you are not dropped into a shell prompt the first time, do not panic. Run a core dump on the application after crashing it with your shell code. Look at the gdp dump and see what the EIP turns out to be. Was it your address from above? Probably not. Time to look at your address area within the buffer to see where you are landing. To look at the 32 bytes around there use x/32 <address> (x/32 0xa1b2c3d4). If you see anything higher in the stack that is not a NOP sled you will have to adjust where the pointer <address> is to land in the NOP sled.

Example 

0xa1b2c310:  0x01020304  0x01020304  0x01020304  0x01020304
0xa1b2c320:  0x01020304  0x01020304  0x01020304  0x01020304
0xa1b2c330:  0x01020304  0x01020304  0x90909090  0x90909090
0xa1b2c340:  0x90909090  0x90909090  0x90909090  0x90909090

Notice that the intial address location (0xa1b2c310) has something other than NOPs and so do the next 32 bytes. Just change your pointer address to 0xa1b2c340 and you will land in the NOP sled, problem solved!








